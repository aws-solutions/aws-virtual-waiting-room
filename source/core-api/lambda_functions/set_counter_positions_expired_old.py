# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

"""
This module is the get_public_key API handler.
It retrieves the public key generated by a custom resource stored in Secrets Manager.
"""

import boto3
import os
import redis
from botocore import config
from time import time
from boto3.dynamodb.conditions import Key
from counters import MAX_QUEUE_POSITION_EXPIRED, QUEUE_COUNTER, SERVING_COUNTER

SECRET_NAME_PREFIX = os.environ["STACK_NAME"]
SOLUTION_ID = os.environ['SOLUTION_ID']
EVENT_ID = os.environ["EVENT_ID"]
REDIS_HOST = os.environ["REDIS_HOST"]
REDIS_PORT = os.environ["REDIS_PORT"]
QUEUE_POSITION_ISSUEDAT_TABLE = os.environ["QUEUE_POSITION_ISSUEDAT_TABLE"]
QUEUE_POSITION_EXPIRY_PERIOD = os.environ["QUEUE_POSITION_EXPIRY_PERIOD"]
SERVING_COUNTER_ISSUEDAT_TABLE = os.environ["SERVING_COUNTER_ISSUEDAT_TABLE"]

user_agent_extra = {"user_agent_extra": SOLUTION_ID}
user_config = config.Config(**user_agent_extra)
boto_session = boto3.session.Session()
region = boto_session.region_name
ddb_resource = boto3.resource('dynamodb', endpoint_url=f'https://dynamodb.{region}.amazonaws.com', config=user_config)
ddb_table_queue_position_issued_at = ddb_resource.Table(QUEUE_POSITION_ISSUEDAT_TABLE)
ddb_table_serving_counter_issued_at = ddb_resource.Table(SERVING_COUNTER_ISSUEDAT_TABLE)
secrets_client = boto3.client('secretsmanager', config=user_config, endpoint_url=f'https://secretsmanager.{region}.amazonaws.com')
response = secrets_client.get_secret_value(SecretId=f"{SECRET_NAME_PREFIX}/redis-auth")
redis_auth = response.get("SecretString")
rc = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, ssl=True, decode_responses=True, password=redis_auth)

def lambda_handler(event, context):
    """
    This function is the entry handler for Lambda.
    """
    print(event)

    # get serving counter items greater than the max expired queue position
    max_queue_position_expired = int(rc.get(MAX_QUEUE_POSITION_EXPIRED))
    current_serving_counter_position = int(rc.get(SERVING_COUNTER))
    current_time = int(time())
    queue_counter = int(rc.get(QUEUE_COUNTER))
    print(f'Queue counter: {queue_counter}')
    print(f'Max queue position expired: {max_queue_position_expired}')
    print(f'Current serving counter: {current_serving_counter_position}')

    # find items in the serving counter table that are greater than the max queue position expired
    response = ddb_table_serving_counter_issued_at.query(
        KeyConditionExpression=Key('event_id').eq(EVENT_ID) & Key('serving_counter').gt(max_queue_position_expired),
        ScanIndexForward=True,
    )
    serving_counter_items = response['Items']
    if not serving_counter_items:
        print('No serving counter items avaialable for checking')
        return

    # find the previous serving counter for increment calculation 
    response =  ddb_table_serving_counter_issued_at.query(
        KeyConditionExpression=Key('event_id').eq(EVENT_ID) & Key('serving_counter').lt(serving_counter_items[0]['serving_counter']),
        ScanIndexForward=False,
        Limit=1
    )
    previous_serving_counter_position = int(response['Items'][0]['serving_counter']) if response['Items'] else 0
    increment_serving_counter_by = 0

    for serving_counter_item in serving_counter_items:
        serving_counter_item_position = int(serving_counter_item['serving_counter'])
        serving_counter_item_issue_time = int(serving_counter_item['issue_time'])
        print(f'Previous serving counter position: {previous_serving_counter_position}')
        print(f'serving counter item position {serving_counter_item_position} issue time: {serving_counter_item_issue_time}')

        # get items between the last max queue position expired value +1 and serving counter item position
        response = ddb_table_queue_position_issued_at.query(
            KeyConditionExpression=Key('event_id').eq(EVENT_ID) & Key('queue_position').between(max_queue_position_expired + 1, serving_counter_item_position),
            ScanIndexForward=False
        )

        if not response['Items']:
            print('No queue positions avaialable to be marked for expiry')
            break

        # try and set max_queue_position_expired within the range of queue position items
        queue_position_items = response['Items']
        is_max_queue_position_set = set_max_queue_expiry_for_queue_items(current_time, serving_counter_item_issue_time, queue_position_items)

        # check for paged reponses
        while not is_max_queue_position_set and 'LastEvaluatedKey' in response:
            response = ddb_table_queue_position_issued_at.query(
                KeyConditionExpression=Key('event_id').eq(EVENT_ID) & Key('queue_position').between(max_queue_position_expired + 1, serving_counter_item_position),
                ExclusiveStartKey=response['LastEvaluatedKey'],
                ScanIndexForward=False
            )
            queue_position_items = response['Items']
            is_max_queue_position_set = set_max_queue_expiry_for_queue_items(current_time, serving_counter_item_issue_time, queue_position_items)

        # keep track of how many items the serving counter has to be incremened by
        if max_queue_position_expired == serving_counter_item_position:
            increment_serving_counter_by += serving_counter_item_position - previous_serving_counter_position - int(serving_counter_item['queue_positions_served'])
            print(f'increment_serving_counter_by: {increment_serving_counter_by} for serving positons between {serving_counter_item_position} - {previous_serving_counter_position}')

        # set previous serving counter to current serving counter item position
        previous_serving_counter_position = serving_counter_item_position 

        # no need to process further items in QUEUE_POSITION_EXPIRY_PERIOD table
        if max_queue_position_expired < serving_counter_item_position:
            break


    if increment_serving_counter_by > 0:    
        increment_serving_counter(ddb_table_serving_counter_issued_at, increment_serving_counter_by)
    else:
        print('Serving counter not incremented')


def set_max_queue_expiry_for_queue_items(current_time, serving_counter_issue_time, queue_position_items):
    """
    Set max expiry counter position from the queue position items
    """
    for queue_item in queue_position_items:
        time_in_queue = max(int(queue_item['issue_time']), serving_counter_issue_time)
        if current_time - time_in_queue > int(QUEUE_POSITION_EXPIRY_PERIOD):
            max_queue_position_expired = rc.set(MAX_QUEUE_POSITION_EXPIRED, int(queue_item['queue_position']))
            print(f'max queue position expired incremented to : {max_queue_position_expired}')
            return True
        
        print('Max queue position not incremented')
    return False


def increment_serving_counter(ddb_table_serving_counter_issued_at, increment_serving_counter_by):
    """
    Increment serving counter if max_queue_position_expired has reached counter value
    """
    cur_serving = rc.incrby(SERVING_COUNTER, int(increment_serving_counter_by))
    item = {
        'event_id': EVENT_ID,
        'serving_counter': cur_serving,
        'issue_time': int(time()),
        'queue_positions_served': 0
    }
    ddb_table_serving_counter_issued_at.put_item(Item=item)
    print(item)
    print(f'Serving counter incremented by {increment_serving_counter_by}. Current value: {cur_serving}')
